module constraints/Statements

imports
    include/JavaLang
    semantic/constraints/Base

// TODO
// - Optional syntax parameters like in return    
// - variable declaration
// - Handle abrubt completion

rules
    generate-constraints: Empty() -> (Unit(), <empty-result>)
    generate-constraints: ExprStm((t, cRes)) -> (Unit(), cRes)
    
    generate-constraints: If((tCond, cCond), (tBody, cBody)) -> (Unit(), cRes)
        where node := "If/2";
              cs   := [CEq(tCond, Boolean(), node)];
              cRes := <merge-result-sets> ([cCond, cBody], cs)
    
    // TODO: constraints for tThen, tElse. equal, Unit?
    generate-constraints: If((tCond, cCond), (tThen, cThen), (tElse, cElse)) -> (Unit(), cRes)
        where node := "If/3";
              cs   := [CEq(tCond, Boolean(), node)];
              cRes := <merge-result-sets> ([cCond, cThen, cElse], cs)
    
    generate-constraints: Block(results) -> (Unit(), cRes)
        where node := "Block";
              cs   := [];
              [(_, cRes)] := <merge-block-stm> [(Unit(), <empty-result>)|<reverse> results] // TODO: get rid of this (possible if merge-block-stm is changed)
    
    // TODO: reverse list and start with an empty result
    merge-block-stm: [] -> [(Unit(), <empty-result>)]
    merge-block-stm: [(t, c)] -> [(t, c)]
    merge-block-stm: [(_, c1), (Unit(), c2) | cs] -> <merge-block-stm> [(Unit(), cRes)|cs]
        where cRes := <merge-result-sets> ([c1, c2], [])
    merge-block-stm: [(_, c1), (UnitLocVar(vars), c2) | cs] -> <merge-block-stm> [(Unit(), cRes)|cs]
        where cRes := <merge-result-sets> ([c1, c2], [], vars)
    
    generate-constraints: LocalVarDecStm((tRes, cRes)) -> (tRes, cRes)
    // TODO: annotations like final?    
    generate-constraints: LocalVarDec(listAnnoOrVarMod, t, listVarDec) -> (UnitLocVar(vars), cRes)
        where node := "LocalVarDec";
              cs   := [];
              vars := <map(\ (UnitVarDec(x), _) -> x \)> listVarDec;
              bNew := <map(\ x -> (x, t) \)> vars;
              cNew := <update-binding-requirements> (<empty-result>, bNew); 
              sets := [cNew|<map(Snd)> listVarDec];
              cRes := <merge-result-sets> (sets, cs)
    
    generate-constraints: VarDec(x) -> (UnitVarDec(x), cRes)
        where tRes := MetaTypeVar(<newname> "T");
              cRes := <add-binding-requirement> (<empty-result>, (x, tRes))
    generate-constraints: VarDec(x, (t, c)) -> (UnitVarDec(x), cRes)
        where cRes := <add-binding-requirement> (c, (x, t))
    
    generate-constraints: While((tExpr, cExpr), (tStm, cStm)) -> (tRes, cRes)
        where node := "While";
              cs   := [CEq(tExpr, Boolean(), node)];
              tRes := Unit();
              cRes := <merge-result-sets> ([cExpr, cStm], cs)

    generate-constraints: DoWhile((tStm, cStm), (tExpr, cExpr)) -> (tRes, cRes)
        where node := "DoWhile";
              cs   := [CEq(tExpr, Boolean(), node)];
              tRes := Unit();
              cRes := <merge-result-sets> ([cExpr, cStm], cs)
    
    generate-constraints: For((UnitLocVar(vars), cVar), Some((tExpr, cExpr)), updateExprs, (tStm, cStm)) -> (tRes, cRes)
        where node  := "BasicFor";
              cs    := [CEq(tExpr, Boolean(), node)];
              tRes  := Unit();
              cRes  := <merge-result-sets> ([cVar, cExpr, cStm| <map(Snd)> updateExprs], cs, vars)
    
    // TODO: ???
    generate-constraints: For(exprs1, expr, exprs2, stm) -> <fail>
    
    // expr is iterable or array type
    generate-constraints: ForEach(formalParam, expr, stm) -> <fail>
    
    generate-constraints: Labeled(label, stm) -> <fail>
    generate-constraints: AssertStm(expr) -> <fail>
    generate-constraints: AssertStm(expr1, expr2) -> <fail>
    generate-constraints: Switch(expr, stm) -> <fail>  
    generate-constraints: SwitchBlock(listSwitchGroup, listSwitchLabel) -> <fail>
    generate-constraints: SwitchGroup(switchLabel, blockStm) -> <fail>
    generate-constraints: Case(expr) -> <fail> // SwitchLabel
    generate-constraints: Default() -> <fail> // SwitchLabel
    // generate-constraints: Break() -> <fail>
    generate-constraints: Break(label) -> <fail> 
    // generate-constraints: Continue() -> <fail>
    generate-constraints: Continue(label) -> <fail>
    // generate-constraints: Return() -> <fail>
    generate-constraints: Return(expr) -> <fail>
    generate-constraints: Throw(expr) -> <fail>
    generate-constraints: Synchronized(expr, blockStm) -> <fail>
    generate-constraints: Try(block, catch) -> <fail>
    generate-constraints: Try(block, listCatch, finallyBlock) -> <fail>
    generate-constraints: Catch(formalParam, block) -> <fail>
    generate-constraints: ClassDecStm(classDec) -> <fail>