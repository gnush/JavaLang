module Main

imports
    include/JavaLang
    semantic/constraints/Main
    semantic/constraints/Base
    semantic/unification/Relations
    semantic/unification/Substitution

// TODO:
// - unification
//  - CEq
//  - CWidenedEq

rules
    /**
     * Unifies a set of constraints.
     * 
     * @param A set of constraints to solve.
     * 
     * @returns A set of constraints that might be solvable with further knowledge.
     * @returns A set of unsolvable constraints (errors)
     * @returns An (partial) unifier.
     */
    unify: ([], mCs, errs, mgu) -> (mCs, errs, mgu)
    
    unify: ([c@CSortOf(type, types, node)|cs], mCs, errs, mgu) -> <if <elem> (type, types)
                                                                    then <unify> (cs, mCs, errs, mgu)
                                                                    else <unify> (cs, mCs, [c|errs], mgu)
                                                                 end>

    unify: ([c@CWidenablePrim(t1, t2, node)|cs], mCs, errs, mgu) -> <if <widen-prim> (t1, t2)
                                                                    then <unify> (cs, mCs, errs, mgu)
                                                                    else <unify> (cs, mCs, [c|errs], mgu)
                                                                   end>

    unify: ([c@CWidenablePrimString(t1, t2, node)|cs], mCs, errs, mgu) -> <if <widen-prim-string> (t1, t2)
                                                                            then <unify> (cs, mCs, errs, mgu)
                                                                            else <unify> (cs, mCs, [c|errs], mgu)
                                                                         end> 

    unify: ([c@CMultiDeclaration(t, types)|cs], mCs, errs, mgu) -> <unify> (cs, mCs, [c|errs], mgu)

    // trivial
    unify: ([CEq(t, t, _)|cs], mCs, errs, mgu) -> <unify> (cs, mCs, errs, mgu)
    // decompose
    // ???
    
    // clash
    
    // skip
    unify: ([c@CEq(MetaTypeVar(t1), MetaTypeVar(t2), _)|cs], mCs, errs, mgu) -> <unify> (cs, [c|mCs], errs, mgu)
    //orient
    unify: ([CEq(t1, t2@MetaTypeVar(_), node)|cs], mCs, errs, mgu) -> <unify> ([CEq(t2, t1, node)|cs], mCs, errs, mgu)
    // occurs check and variable elimination
    unify: ([c@CEq(MetaTypeVar(x), t, node)|cs], mCs, errs, mgu) -> <if <occurs> (x, t)
                                                                        then <unify> (cs, mCs, [c|errs], mgu)
                                                                        else <unify> (cs', mCs', errs', mgu')
                                                                     end>
    where
        cs'   := <substitute-constraints> (x, t, cs);
        mCs'  := <substitute-constraints> (x, t, mCs);
        errs' := <substitute-constraints> (x, t, errs);
        mgu'  := [(x, t)|<substitute-mgu> (x, t, mgu)]

    // TODO: remove this
    unify: ([c|cs], mCs, errs, mgu) -> <unify> (cs, [c|mCs], errs, mgu)

    unify = debug(!"unify: "); fail

    